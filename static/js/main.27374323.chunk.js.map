{"version":3,"sources":["Main.js","serviceWorker.js","index.js"],"names":["Main","props","handleScreenShot","event","setState","prevState","isToggleOn","state","wecamDisplay","screenDisplay","handleSave","image","document","getElementById","toDataURL","href","handleZoomIn","scaleWidth","width","scaleHeight","height","handleZoomOut","filter","herf","this","webcam","timerID","setInterval","webcamToCanvas","clearInterval","inputVideo","querySelector","filter1","filter2","filter3","constraints","video","navigator","mediaDevices","getUserMedia","then","stream","window","srcObject","catch","error","name","alert","exact","canvas","videoWidth","videoHeight","getContext","drawImage","text","buttonText","filterStyle","style","display","flexDirection","alignItems","justifyContent","id","autoPlay","textAlign","fontFamily","className","onClick","download","React","Component","Boolean","location","hostname","match","ReactDOM","render","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.27374323.chunk.js","sourcesContent":["import React from \"react\"\r\nclass Main extends React.Component {\r\n\tconstructor(props) {\r\n        super(props);\r\n        this.state={\r\n        wecamDisplay:\"inline\",\r\n        screenDisplay:\"none\",\r\n        filter:\"sepia\",\r\n        isToggleOn:true,\r\n        herf:\"\",\r\n        width:800,\r\n        height:500,\r\n        scaleWidth:0,\r\n        scaleHeight:0,\r\n        }\r\n    }\r\n\r\n    //component被render到DOM之後才會執行\r\n    componentDidMount(){\r\n        this.webcam();\r\n        this.timerID = setInterval(\r\n            () => this.webcamToCanvas(),\r\n            100\r\n          );\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        clearInterval(this.timerID);\r\n    }\r\n\r\n    //網路攝影機\r\n    webcam() {\r\n        let inputVideo = document.querySelector('#video');\r\n        let filter1 = document.querySelector('#filter1');\r\n        let filter2 = document.querySelector('#filter2');\r\n        let filter3 = document.querySelector('#filter3');\r\n        let constraints = {\r\n            video: {width:this.state.width, height:this.state.height}\r\n        }\r\n         // 請求開啟影音裝置\r\n         navigator.mediaDevices.getUserMedia(constraints)\r\n         .then(function (stream) {\r\n            window.stream = stream; \r\n            inputVideo.srcObject = stream;\r\n            filter1.srcObject = stream;\r\n            filter2.srcObject = stream;\r\n            filter3.srcObject = stream;\r\n         })\r\n         .catch(function (error) {\r\n        //錯誤訊息\r\n            if (error.name === 'ConstraintNotSatisfiedError') {\r\n                alert('The resolution ' + constraints.video.width.exact + 'x' +\r\n                    constraints.video.width.exact + ' px is not supported by your device.');\r\n              } else if (error.name === 'PermissionDeniedError') {\r\n                alert('Permissions have not been granted to use your camera and ' +\r\n                  'microphone, you need to allow the page access to your devices in ' +\r\n                  'order for the demo to work.');\r\n              }\r\n                alert('getUserMedia error: ' + error.name, error);\r\n         });\r\n    }\r\n\r\n    //將攝影鏡頭轉到canvas上\r\n    webcamToCanvas(){\r\n        if(this.state.isToggleOn==true){\r\n            const video = document.querySelector('#video');\r\n            const canvas = document.querySelector('#webcamCanvas');\r\n            canvas.width = video.videoWidth;\r\n            canvas.height = video.videoHeight;\r\n            canvas.getContext('2d').drawImage(video,this.state.scaleWidth,this.state.scaleHeight,this.state.width,this.state.height);\r\n        }\r\n    }\r\n\r\n\r\n    //處理螢幕截圖的按鈕\r\n    handleScreenShot=event=> {\r\n        this.setState(prevState => ({isToggleOn:!prevState.isToggleOn}));\r\n        if(this.state.isToggleOn==true){\r\n            this.setState(({wecamDisplay:\"none\",screenDisplay:\"inline\"}));  \r\n        }else{\r\n            this.setState(({wecamDisplay:\"inline\",screenDisplay:\"none\"}));  \r\n        }\r\n\r\n    }\r\n\r\n    //儲存圖片的按鈕\r\n    handleSave=event=> {\r\n        var mycanvas = document.getElementById(\"webcamCanvas\");\r\n        var image = mycanvas.toDataURL(\"image/jpg\");\r\n        this.setState({href:image});\r\n    }\r\n\r\n    //放大按鈕\r\n    handleZoomIn=event=> {\r\n        const scaleWidth=this.state.scaleWidth-(this.state.width*1.2-this.state.width)/2;\r\n        const scaleHeight=this.state.scaleHeight-(this.state.height*1.2-this.state.height)/2;\r\n        let width = this.state.width;\r\n        width = width*1.2;\r\n        let height = this.state.height;\r\n        height = height*1.2;\r\n        this.setState({width:width,height:height,scaleWidth:scaleWidth,scaleHeight:scaleHeight});\r\n\r\n    }\r\n\r\n    //縮小按鈕\r\n    handleZoomOut=event=> {\r\n        const scaleWidth=this.state.scaleWidth+(this.state.width-this.state.width/2)/2;\r\n        const scaleHeight=this.state.scaleHeight+(this.state.height-this.state.height/2)/2;\r\n        let width = this.state.width;\r\n        width = width/2;\r\n        let height = this.state.height;\r\n        height = height/2;\r\n        this.setState({width:width,height:height,scaleWidth:scaleWidth,scaleHeight:scaleHeight});\r\n    }\r\n\r\n\r\n    render() {\r\n        let text = null;\r\n        (this.state.isToggleOn?text=\"webcam\":text=\"screenShot\");\r\n        let buttonText = null;\r\n        (this.state.isToggleOn?buttonText=\"screenShot\":buttonText=\"webcam\");\r\n        const filterStyle=[\"grayfilter\",\"sepia\",\"blur\",\"invert\"];\r\n        return (\r\n            <div style={{display:\"flex\",flexDirection:\"column\",alignItems:\"center\",justifyContent:\"center\"}}>\r\n                <div>\r\n                    <canvas id=\"webcamCanvas\"></canvas>\r\n                    <video  style={{display:\"none\"}} id=\"video\" autoPlay>\r\n                            Your browser does not support HTML5 video.\r\n                    </video>\r\n                    <h1 style={{textAlign:\"center\",fontFamily:\"ProximaNova-Bold\"}}>{text}</h1>\r\n                </div>\r\n                <div style={{display:\"flex\"}}>\r\n                    <button className=\"buttonStyle\" onClick={this.handleScreenShot}>{buttonText}</button>\r\n                    <a id=\"download\" download=\"screenshot.jpg\" href={this.state.href} style={{display:this.state.screenDisplay}} onClick={this.handleSave}><button>Save</button></a>\r\n                    <button className=\"buttonStyle\" onClick={this.handleZoomIn}  style={{display:this.state.wecamDisplay}}>zoom in</button>\r\n                    <button className=\"buttonStyle\" onClick={this.handleZoomOut} style={{display:this.state.wecamDisplay}}>zoom out</button>\r\n                </div>\r\n                <div style={{display:\"flex\"}}>\r\n                    <video className={filterStyle[0]} id=\"filter1\" style={{display:this.state.wecamDisplay}} autoPlay></video>\r\n                    <video className={filterStyle[1]} id=\"filter2\" style={{display:this.state.wecamDisplay}} autoPlay></video>\r\n                    <video className={filterStyle[2]} id=\"filter3\" style={{display:this.state.wecamDisplay}} autoPlay></video>\r\n                </div>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Main;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Main from './Main';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Main />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}